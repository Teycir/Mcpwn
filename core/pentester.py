"""MCP Pentester - Main testing orchestrator"""
import json
import subprocess
import time
import threading
from core.detector import SemanticDetector
from payloads import PAYLOADS


class MCPPentester:
    """MCP security testing engine"""
    def __init__(self, server_cmd, config=None):
        self.server_cmd = server_cmd
        self.proc = None
        self.detector = SemanticDetector()
        self.tools = []
        self.resources = []
        self.config = config or {}
        self.lock = threading.Lock()
        self._request_id = 0

    def start(self):
        """Start MCP server"""
        try:
            self.proc = subprocess.Popen(
                self.server_cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except (OSError, subprocess.SubprocessError) as e:
            raise RuntimeError(f"Failed to start MCP server: {e}")

    def stop(self):
        """Stop MCP server"""
        if self.proc:
            try:
                self.proc.terminate()
                self.proc.wait(timeout=5)
            except Exception as e:
                print(f"[!] Process cleanup failed, forcing kill: {e}")
                if self.proc:
                    try:
                        self.proc.kill()
                    except Exception as e:
                        print(f"[!] Process kill failed: {e}")

    def __enter__(self):
        """Context manager entry"""
        self.start()
        return self

    def __exit__(self, *args):
        """Context manager exit"""
        self.stop()

    def restart_server(self):
        """Safely restart server process"""
        if self.proc:
            try:
                self.proc.terminate()
                self.proc.wait(timeout=5)
            except Exception as e:
                print(f"[!] Server termination failed, forcing kill: {e}")
                self.proc.kill()
        self.start()

    def health_check(self):
        """Verify server is responsive"""
        if not self.proc or self.proc.poll() is not None:
            try:
                self.restart_server()
            except Exception as e:
                print(f"[!] Health check failed: {e}")
                return False
            return False
        return True

    def send(self, method, params=None, skip_analysis=False):
        """Send JSON-RPC request and measure timing (thread-safe)"""
        with self.lock:
            self._request_id += 1
            msg = {
                "jsonrpc": "2.0",
                "id": self._request_id,
                "method": method,
                "params": params or {}
            }

            start = time.time()
            try:
                self.proc.stdin.write(json.dumps(msg) + '\n')
                self.proc.stdin.flush()
                response = self.proc.stdout.readline()
            except (IOError, OSError, BrokenPipeError) as e:
                raise RuntimeError(f"Communication with MCP server failed: {e}")
            elapsed = time.time() - start

            try:
                parsed = json.loads(response) if response else {}
            except json.JSONDecodeError:
                parsed = response

            # Auto-analyze (skip for baseline/discovery)
            if self.detector and not skip_analysis:
                self.detector.analyze(parsed, elapsed)

            return parsed, elapsed

    def discover(self):
        """Discovery phase - enumerate attack surface"""
        try:
            # Skip analysis during discovery to establish baseline
            resp, elapsed = self.send("initialize", {
                "protocolVersion": "2024-11-05",
                "capabilities": {},
                "clientInfo": {"name": "mcpwn", "version": "1.0"}
            }, skip_analysis=True)
            self.detector.analyze(resp, elapsed, is_baseline=True)

            tools_resp, elapsed = self.send("tools/list", skip_analysis=True)
            self.detector.analyze(tools_resp, elapsed, is_baseline=True)
            self.tools = tools_resp.get('result', {}).get('tools', [])

            res_resp, elapsed = self.send("resources/list", skip_analysis=True)
            self.detector.analyze(res_resp, elapsed, is_baseline=True)
            self.resources = res_resp.get('result', {}).get('resources', [])
        except Exception as e:
            print(f"[!] Discovery failed: {e}")
            self.tools = []
            self.resources = []

        return self.tools, self.resources

    def run(self):
        """Execute full pentest suite"""
        # pylint: disable=import-outside-toplevel,no-name-in-module
        from tests.state_desync import StateDesyncTest
        from tests.tool_injection import ToolInjectionTest
        from tests.resource_traversal import ResourceTraversalTest
        from tests.subscription_flood import SubscriptionFloodTest
        from tests.prompt_injection import PromptInjectionTest
        from tests.protocol_fuzzing import ProtocolFuzzingTest
        from core.reporter import Reporter

        reporter = Reporter()
        print("[*] Starting Mcpwn")

        # Skip state desync in quick/RCE-only mode
        if not self.config.get('rce_only') and not self.config.get('quick'):
            # Tier 1: State desync
            print("\n[*] Testing state desync...")
            desync_test = StateDesyncTest(self)
            desync = desync_test.run()
            reporter.add_findings('state_desync', 
                                  [{'finding': f} for f in desync])
            for f in desync:
                print(f"  [!] {f}")

        # Discovery
        self.start()
        print("\n[*] Discovery phase...")
        tools, resources = self.discover()
        print(f"  [+] Found {len(tools)} tools, {len(resources)} resources")

        # Tier 1: Tool injection
        print("\n[*] Testing tool injection...")
        injection_test = ToolInjectionTest(self)
        for tool in tools:
            try:
                findings = injection_test.run(tool)
                reporter.add_findings('tool_injection', findings)
                for f in findings:
                    print(f"  [!] {tool['name']}: {f['category']} via "
                          f"{f['arg']}")
                    for d in f['detections']:
                        print(f"      {d}")
            except Exception as e:
                print(f"  [!] Tool injection test failed for {tool.get('name', 'unknown')}: {e}")

        # Skip non-RCE tests in RCE-only mode
        if not self.config.get('rce_only'):
            # Tier 1: Path traversal
            print("\n[*] Testing path traversal...")
            traversal_test = ResourceTraversalTest(self)
            traversal = traversal_test.run()
            reporter.add_findings('path_traversal', traversal)
            for f in traversal:
                print(f"  [!] {f['uri']}")
                for d in f['detections']:
                    print(f"      {d}")

        # Tier 2: Subscription flood
        if not self.config.get('safe_mode'):
            print("\n[*] Testing subscription flood...")
            try:
                flood_test = SubscriptionFloodTest(self)
                parallel = self.config.get('parallel', True)
                flood = flood_test.run(parallel=parallel)
                reporter.add_findings('subscription_flood', [flood])
                print(f"  [+] {flood['count']} subscriptions in "
                      f"{flood['elapsed']:.2f}s ({flood['rate']:.0f}/s)")
            except Exception as e:
                print(f"  [!] Subscription flood test failed: {e}")
        else:
            print("\n[*] Skipping subscription flood (safe mode)")

        # Skip non-RCE tests in RCE-only mode
        if not self.config.get('rce_only'):
            # Tier 2: Prompt injection
            print("\n[*] Testing prompt injection...")
            try:
                prompt_test = PromptInjectionTest(self)
                for tool in tools:
                    try:
                        prompt_findings = prompt_test.run(tool)
                        reporter.add_findings('prompt_injection', prompt_findings)
                        for f in prompt_findings:
                            print(f"  [!] {tool['name']}: {f['risk']}")
                    except Exception as e:
                        print(f"  [!] Prompt injection test failed for {tool.get('name', 'unknown')}: {e}")
            except Exception as e:
                print(f"  [!] Prompt injection test initialization failed: {e}")

            # Tier 2: Protocol fuzzing
            print("\n[*] Testing protocol fuzzing...")
            try:
                fuzz_test = ProtocolFuzzingTest(self)
                fuzz_findings = fuzz_test.run()
                reporter.add_findings('protocol_fuzzing', fuzz_findings)
                for f in fuzz_findings:
                    print(f"  [!] {f['type']}: {f.get('risk', 'Parser error')}")
            except Exception as e:
                print(f"  [!] Protocol fuzzing test failed: {e}")

        if self.proc:
            try:
                self.proc.terminate()
                self.proc.wait(timeout=5)
            except Exception as e:
                print(f"[!] Process cleanup failed, forcing kill: {e}")
                if self.proc:
                    try:
                        self.proc.kill()
                    except Exception as e:
                        print(f"[!] Process kill failed: {e}")
        print("\n[*] Mcpwn complete")

        # Generate reports if requested
        if self.config.get('output_json'):
            try:
                reporter.to_json(self.config['output_json'])
                print(f"[+] JSON report: {self.config['output_json']}")
            except Exception as e:
                print(f"[!] Failed to generate JSON report: {e}")
        if self.config.get('output_html'):
            try:
                reporter.to_html(self.config['output_html'])
                print(f"[+] HTML report: {self.config['output_html']}")
            except Exception as e:
                print(f"[!] Failed to generate HTML report: {e}")
