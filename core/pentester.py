"""MCP Pentester - Main testing orchestrator"""
import json
import subprocess
import time
import threading
import select
import logging
from core.detector import SemanticDetector
from core.generator import initialize_generator, get_generator
from payloads import PAYLOADS

logger = logging.getLogger('mcpwn')


class MCPPentester:
    """MCP security testing engine"""
    def __init__(self, server_cmd, config=None):
        self.server_cmd = server_cmd
        self.proc = None
        self.detector = SemanticDetector()
        self.tools = []
        self.resources = []
        self.config = config or {}
        self.lock = threading.Lock()
        self.health_lock = threading.Lock()
        self.send_lock = threading.Lock()
        self._request_id = 0
        self.last_health_check = 0
        
        # Initialize LLM generator if enabled
        if self.config.get('generation_mode'):
            initialize_generator(self.config)
            logger.info("LLM-guided generation enabled")

    def start(self):
        """Start MCP server"""
        try:
            self.proc = subprocess.Popen(
                self.server_cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
        except (OSError, subprocess.SubprocessError) as e:
            raise RuntimeError(f"Failed to start MCP server: {e}")

    def stop(self):
        """Stop MCP server"""
        if self.proc:
            try:
                self.proc.terminate()
                self.proc.wait(timeout=5)
            except (subprocess.TimeoutExpired, OSError) as e:
                logger.warning("Process cleanup failed, forcing kill: %s", e)
                if self.proc:
                    try:
                        self.proc.kill()
                    except OSError as e:
                        logger.error("Process kill failed: %s", e, exc_info=True)

    def __enter__(self):
        """Context manager entry"""
        self.start()
        return self

    def __exit__(self, *args):
        """Context manager exit"""
        self.stop()

    def restart_server(self):
        """Restart the MCP server process"""
        self.stop()
        self.start()
        self.initialize()

    def initialize(self):
        """Send initialize request to server"""
        self.send("initialize", {
            "protocolVersion": "2024-11-05",
            "capabilities": {},
            "clientInfo": {"name": "mcpwn", "version": "1.0"}
        }, skip_analysis=True)

    def health_check(self):
        """Verify server is responsive"""
        with self.health_lock:
            if time.time() - self.last_health_check < 5:
                return True
            if not self.proc or self.proc.poll() is not None:
                try:
                    self.restart_server()
                except (RuntimeError, OSError, subprocess.SubprocessError) as e:
                    logger.error("Health check failed: %s", e, exc_info=True)
                    return False
                self.last_health_check = time.time()
                return False
            self.last_health_check = time.time()
            return True

    def send(self, method, params=None, skip_analysis=False, timeout=None):
        """Send JSON-RPC request with configurable timeout"""
        with self.lock:
            self._request_id += 1
            req_id = self._request_id
        
        msg = {
            "jsonrpc": "2.0",
            "id": req_id,
            "method": method,
            "params": params or {}
        }

        timeout = timeout or self.config.get('timeout', 30)
        deadline = time.time() + timeout
        start = time.time()
        
        with self.send_lock:
            try:
                self.proc.stdin.write(json.dumps(msg) + '\n')
                self.proc.stdin.flush()
                
                remaining = deadline - time.time()
                if remaining <= 0:
                    raise TimeoutError(f"Server unresponsive after {timeout}s")
                
                ready, _, _ = select.select([self.proc.stdout], [], [], remaining)
                
                if not ready:
                    raise TimeoutError(f"Server unresponsive after {timeout}s")
                
                response_str = self.proc.stdout.readline()
            except (IOError, OSError, BrokenPipeError) as e:
                raise RuntimeError(f"Communication with MCP server failed: {e}")
        
        elapsed = time.time() - start

        try:
            parsed = json.loads(response_str) if response_str else {}
        except json.JSONDecodeError:
            parsed = response_str

        # Auto-analyze with raw response string
        if self.detector and not skip_analysis:
            self.detector.analyze(parsed, response_str, elapsed)

        return parsed, elapsed

    def discover(self):
        """Discovery phase - enumerate attack surface"""
        try:
            # Skip analysis during discovery to establish baseline
            resp, elapsed = self.send("initialize", {
                "protocolVersion": "2024-11-05",
                "capabilities": {},
                "clientInfo": {"name": "mcpwn", "version": "1.0"}
            }, skip_analysis=True)
            self.detector.analyze(resp, "", elapsed, is_baseline=True)

            tools_resp, elapsed = self.send("tools/list", skip_analysis=True)
            self.detector.analyze(tools_resp, "", elapsed, is_baseline=True)
            self.tools = tools_resp.get('result', {}).get('tools', [])

            res_resp, elapsed = self.send("resources/list", skip_analysis=True)
            self.detector.analyze(res_resp, "", elapsed, is_baseline=True)
            self.resources = res_resp.get('result', {}).get('resources', [])
        except (RuntimeError, TimeoutError, json.JSONDecodeError, KeyError) as e:
            logger.error("Discovery failed: %s", e, exc_info=True)
            self.tools = []
            self.resources = []

        return self.tools, self.resources

    def get_payloads(self, context):
        """Get payloads: LLM-generated if enabled, else static."""
        generator = get_generator()
        if generator and generator.enabled:
            generated = generator.generate(context)
            if generated:
                return generated
            logger.warning("LLM generation failed, using static payloads")
        
        # Fallback to static payloads
        target_type = context.get('target_type', 'rce')
        return PAYLOADS.get(target_type, PAYLOADS.get('rce', []))

    def run(self):
        """Execute full pentest suite"""
        # pylint: disable=import-outside-toplevel,no-name-in-module
        from tests.state_desync import StateDesyncTest
        from tests.capability_fuzzing import CapabilityFuzzingTest
        from tests.tool_injection import ToolInjectionTest
        from tests.resource_traversal import ResourceTraversalTest
        from tests.subscription_flood import SubscriptionFloodTest
        from tests.prompt_injection import PromptInjectionTest
        from tests.protocol_fuzzing import ProtocolFuzzingTest
        from tests.oob_detection import OOBTest
        from tests.race_condition import RaceConditionTest
        from tests.resource_exhaustion import ResourceExhaustionTest
        from core.reporter import Reporter

        reporter = Reporter()
        logger.info("Starting Mcpwn")

        # Skip state desync in quick/RCE-only mode
        if not self.config.get('rce_only') and not self.config.get('quick'):
            # Tier 1: State desync
            logger.info("Testing state desync...")
            desync_test = StateDesyncTest(self)
            desync = desync_test.run()
            reporter.add_findings('state_desync', 
                                  [{'finding': f} for f in desync])
            for f in desync:
                logger.warning("State desync: %s", f)
            
            # Tier 1: Capability fuzzing
            logger.info("Testing capability fuzzing...")
            cap_test = CapabilityFuzzingTest(self)
            cap_findings = cap_test.run()
            reporter.add_findings('capability_fuzzing', cap_findings)
            for f in cap_findings:
                logger.warning("Capability issue: %s", f['type'])

        # Discovery
        self.start()
        logger.info("Discovery phase...")
        tools, resources = self.discover()
        logger.info("Found %d tools, %d resources", len(tools), len(resources))

        # Tier 1: Tool injection
        logger.info("Testing tool injection...")
        injection_test = ToolInjectionTest(self)
        for tool in tools:
            try:
                findings = injection_test.run(tool)
                reporter.add_findings('tool_injection', findings)
                for f in findings:
                    logger.warning("%s: %s via %s", tool['name'], f['category'], f['arg'])
                    for d in f['detections']:
                        logger.warning("  Detection: %s", d)
                if self.config.get('quick') and findings:
                    break
            except (RuntimeError, TimeoutError, KeyError, TypeError) as e:
                logger.error("Tool injection test failed for %s: %s", tool.get('name', 'unknown'), e)

        # Skip non-RCE tests in RCE-only mode
        if not self.config.get('rce_only'):
            # Tier 1: Path traversal
            logger.info("Testing path traversal...")
            traversal_test = ResourceTraversalTest(self)
            traversal = traversal_test.run()
            reporter.add_findings('path_traversal', traversal)
            for f in traversal:
                logger.warning("Path traversal: %s", f['uri'])
                for d in f['detections']:
                    logger.warning("  Detection: %s", d)

        # Tier 2: Subscription flood
        if not self.config.get('safe_mode'):
            logger.info("Testing subscription flood...")
            try:
                flood_test = SubscriptionFloodTest(self)
                parallel = self.config.get('parallel', True)
                flood = flood_test.run(parallel=parallel)
                reporter.add_findings('subscription_flood', [flood])
                logger.info("%d subscriptions in %.2fs (%.0f/s)", 
                           flood['count'], flood['elapsed'], flood['rate'])
            except (RuntimeError, TimeoutError, KeyError) as e:
                logger.error("Subscription flood test failed: %s", e, exc_info=True)
        else:
            logger.info("Skipping subscription flood (safe mode)")

        # Skip non-RCE tests in RCE-only mode
        if not self.config.get('rce_only'):
            # Tier 2: Prompt injection
            logger.info("Testing prompt injection...")
            try:
                prompt_test = PromptInjectionTest(self)
                for tool in tools:
                    try:
                        prompt_findings = prompt_test.run(tool)
                        reporter.add_findings('prompt_injection', prompt_findings)
                        for f in prompt_findings:
                            logger.warning("%s: %s", tool['name'], f['risk'])
                    except (RuntimeError, TimeoutError, KeyError, TypeError) as e:
                        logger.error("Prompt injection test failed for %s: %s", tool.get('name', 'unknown'), e)
            except (RuntimeError, ImportError) as e:
                logger.error("Prompt injection test initialization failed: %s", e, exc_info=True)

            # Tier 2: Protocol fuzzing
            if not self.config.get('safe_mode'):
                logger.info("Testing protocol fuzzing...")
                try:
                    fuzz_test = ProtocolFuzzingTest(self)
                    fuzz_findings = fuzz_test.run()
                    reporter.add_findings('protocol_fuzzing', fuzz_findings)
                    for f in fuzz_findings:
                        logger.warning("%s: %s", f['type'], f.get('risk', 'Parser error'))
                    fuzz_test.cleanup()
                except (RuntimeError, TimeoutError) as e:
                    logger.error("Protocol fuzzing test failed: %s", e, exc_info=True)
            else:
                logger.info("Skipping protocol fuzzing (safe mode)")

            # Tier 3: OOB detection
            logger.info("Testing OOB DNS exfiltration...")
            try:
                oob_test = OOBTest(self)
                for tool in tools:
                    try:
                        oob_findings = oob_test.run(tool)
                        reporter.add_findings('oob_detection', oob_findings)
                        for f in oob_findings:
                            logger.warning("%s: OOB DNS via %s", tool['name'], f['arg'])
                    except (RuntimeError, TimeoutError, KeyError, TypeError) as e:
                        logger.error("OOB test failed for %s: %s", tool.get('name', 'unknown'), e)
                oob_test.cleanup()
            except (RuntimeError, ImportError) as e:
                logger.error("OOB test initialization failed: %s", e, exc_info=True)

            # Tier 3: Race conditions
            logger.info("Testing race conditions...")
            try:
                race_test = RaceConditionTest(self)
                for tool in tools:
                    try:
                        race_findings = race_test.run(tool)
                        reporter.add_findings('race_condition', race_findings)
                        for f in race_findings:
                            logger.warning("%s: %s", tool['name'], f['type'])
                    except (RuntimeError, TimeoutError, KeyError, TypeError) as e:
                        logger.error("Race test failed for %s: %s", tool.get('name', 'unknown'), e)
            except (RuntimeError, ImportError) as e:
                logger.error("Race test initialization failed: %s", e, exc_info=True)

            # Tier 3: Resource exhaustion
            if not self.config.get('safe_mode'):
                logger.info("Testing resource exhaustion...")
                try:
                    exhaust_test = ResourceExhaustionTest(self)
                    for tool in tools:
                        try:
                            exhaust_findings = exhaust_test.run(tool, quick_mode=self.config.get('quick'))
                            reporter.add_findings('resource_exhaustion', exhaust_findings)
                            for f in exhaust_findings:
                                logger.warning("%s: %s", tool['name'], f['type'])
                        except (RuntimeError, TimeoutError, KeyError, TypeError) as e:
                            logger.error("Exhaustion test failed for %s: %s", tool.get('name', 'unknown'), e)
                except (RuntimeError, ImportError) as e:
                    logger.error("Exhaustion test initialization failed: %s", e, exc_info=True)
            else:
                logger.info("Skipping resource exhaustion tests (safe mode)")

        if self.proc:
            try:
                self.proc.terminate()
                self.proc.wait(timeout=5)
            except (subprocess.TimeoutExpired, OSError) as e:
                logger.warning("Process cleanup failed, forcing kill: %s", e)
                if self.proc:
                    try:
                        self.proc.kill()
                    except OSError as e:
                        logger.error("Process kill failed: %s", e, exc_info=True)
        logger.info("Mcpwn complete")

        # Generate reports if requested
        if self.config.get('output_json'):
            try:
                reporter.to_json(self.config['output_json'])
                logger.info("JSON report: %s", self.config['output_json'])
            except (IOError, OSError, json.JSONDecodeError) as e:
                logger.error("Failed to generate JSON report: %s", e, exc_info=True)
        if self.config.get('output_html'):
            try:
                reporter.to_html(self.config['output_html'])
                logger.info("HTML report: %s", self.config['output_html'])
            except (IOError, OSError) as e:
                logger.error("Failed to generate HTML report: %s", e, exc_info=True)
        if self.config.get('output_sarif'):
            try:
                reporter.to_sarif(self.config['output_sarif'])
                logger.info("SARIF report: %s", self.config['output_sarif'])
            except (IOError, OSError, json.JSONDecodeError) as e:
                logger.error("Failed to generate SARIF report: %s", e, exc_info=True)
